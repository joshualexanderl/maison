<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: white;
            overflow: hidden;
            position: relative;
        }

        .orb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: black;
            cursor: pointer;
            animation: pulsingBall 2s ease-in-out infinite alternate;
            /* Start visible and animating immediately */
        }

        @keyframes pulsingBall {
            0% {
                transform: scale(4);
                filter: blur(15px);
            }
            100% {
                transform: scale(1);
                filter: blur(5px);
            }
        }

        .orb:hover {
            animation: pulsingBallFast 1s ease-in-out infinite alternate;
        }

        @keyframes pulsingBallFast {
            0% {
                transform: scale(4);
                filter: blur(15px);
            }
            100% {
                transform: scale(1);
                filter: blur(5px);
            }
        }

        .text {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            color: black;
            letter-spacing: 2px;
        }

        #pageCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            opacity: 1;
            transition: none;
        }

        .pixelated-canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            image-rendering: optimizeSpeed;
            image-rendering: -o-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
        }
    </style>
</head>
<body>
    <div class="orb"></div>
    <div class="text">maison</div>
    <canvas id="pageCanvas" class="pixelated-canvas"></canvas>

    <script>
        const orb = document.querySelector('.orb');
        const canvas = document.getElementById('pageCanvas');
        const ctx = canvas.getContext('2d');
        
        let isAnimating = true;
        let timeoutId = null;

        // EXACT PARAMETERS FROM PIXELATEDIMAGE COMPONENT
        const CANVAS_WIDTH = 128;  // Line 60: Fixed canvas width
        const START_PIXEL_SIZE = 16;  // Line 29, 136: Starting pixel size
        const BASE_DELAY = 156;  // Line 137: Original timing
        const ACCELERATION = 0.5;  // Line 150: Acceleration rate
        const STAGGER_BASE = 150;  // Line 72: First image delay
        const FADE_DURATION = 800;  // Lines 228, 246: Fade duration
        const EASING_CURVE = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)';  // Lines 228, 246

        // Set canvas size
        const containerRect = document.body.getBoundingClientRect();
        const safeContainerW = Math.max(0, Math.floor(containerRect.width));
        const safeContainerH = Math.max(0, Math.floor(containerRect.height));
        let aspectRatio = 1;
        if (safeContainerW > 0 && safeContainerH > 0) {
            aspectRatio = safeContainerH / safeContainerW;
        }

        canvas.width = CANVAS_WIDTH;
        canvas.height = Math.max(1, Math.floor(CANVAS_WIDTH * aspectRatio));

        // Disable image smoothing for pixelated effect (EXACT from legacy)
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        // Capture page content to canvas at CURRENT animated state
        async function capturePageContent() {
            return new Promise((resolve) => {
                // Small delay to capture a frame of the animation
                setTimeout(() => {
                    const refCanvas = document.createElement('canvas');
                    refCanvas.width = canvas.width;
                    refCanvas.height = canvas.height;
                    const refCtx = refCanvas.getContext('2d');
                    refCtx.imageSmoothingEnabled = false;
                    
                    // Fill white background
                    refCtx.fillStyle = '#ffffff';
                    refCtx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the orb's CURRENT computed style (including transform and filter)
                    const orbRect = orb.getBoundingClientRect();
                    const orbStyle = window.getComputedStyle(orb);
                    
                    // Calculate position on canvas (maintaining center)
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Get the current transform to determine scale
                    const transform = orbStyle.transform;
                    let scale = 1;
                    if (transform && transform !== 'none') {
                        const matrix = new DOMMatrix(transform);
                        scale = matrix.a; // scale from matrix
                    }
                    
                    // Get current blur amount
                    const filter = orbStyle.filter;
                    let blur = 10; // default
                    if (filter && filter.includes('blur')) {
                        const match = filter.match(/blur\((\d+)px\)/);
                        if (match) blur = parseInt(match[1]);
                    }
                    
                    // Draw orb at its CURRENT animated state
                    const currentRadius = 10 * scale;
                    const blurRadius = Math.max(blur / 2, 1);
                    
                    refCtx.save();
                    refCtx.fillStyle = 'black';
                    refCtx.filter = `blur(${blurRadius}px)`;
                    refCtx.beginPath();
                    refCtx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
                    refCtx.fill();
                    refCtx.restore();
                    
                    // Draw the text (centered at bottom)
                    const textElement = document.querySelector('.text');
                    const textRect = textElement.getBoundingClientRect();
                    const textX = canvas.width / 2;
                    const textY = (textRect.top / window.innerHeight) * canvas.height + 2;
                    
                    refCtx.fillStyle = 'black';
                    refCtx.font = '2px "Courier New", monospace';
                    refCtx.textAlign = 'center';
                    refCtx.letterSpacing = '0.2px';
                    refCtx.fillText('maison', textX, textY);
                    
                    resolve(refCanvas);
                }, 50); // Capture after a brief moment of animation
            });
        }

        // ═══════════════════════════════════════════════════════════
        // EXACT PIXELATION DRAWING ALGORITHM (from PixelatedImage.tsx)
        // ═══════════════════════════════════════════════════════════
        function drawPixelated(context, image, width, height, pixelSize) {
            if (!width || !height) return;
            
            // Original reference algorithm
            const aspectRatio = width / height;
            const canvasHeight = Math.floor(Math.round(128 / aspectRatio) / pixelSize) * pixelSize;
            
            // Set canvas size to fixed 128px width (original approach)
            const canvasWidth = 128;
            const scaledWidth = Math.round(canvasWidth / pixelSize);
            const scaledHeight = Math.round(canvasHeight / pixelSize);
            
            // Clear canvas
            context.clearRect(0, 0, width, height);
            
            // Disable smoothing for crisp pixels
            context.imageSmoothingEnabled = false;
            context.mozImageSmoothingEnabled = false;
            context.msImageSmoothingEnabled = false;
            context.webkitImageSmoothingEnabled = false;
            
            // Fill with white background
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, scaledWidth, scaledHeight);
            
            // Draw image at small size
            context.drawImage(image, 0, 0, scaledWidth, scaledHeight);
            
            // Scale back up to full size
            if (canvas) {
                context.drawImage(canvas, 0, 0, scaledWidth, scaledHeight, 0, 0, width, height);
            }
        }

        // ═══════════════════════════════════════════════════════════
        // THE ANIMATION SEQUENCE (EXACT timing from component)
        // ═══════════════════════════════════════════════════════════
        async function startPixelatedTransition() {
            const tempImg = await capturePageContent();
            
            console.log('Starting pixelation for page:', 'canvas size:', canvas.width, 'x', canvas.height);
            
            // Original reference recursive pixelation
            let currentPixelSize = START_PIXEL_SIZE;  // EXACT: Line 136
            let intervalDelay = BASE_DELAY;  // EXACT: Line 137 - Original timing

            function nextPixelStep() {
                if (currentPixelSize >= 1) {
                    console.log('Pixelation step, pixel size:', currentPixelSize);
                    
                    if (canvas && ctx) {
                        drawPixelated(ctx, tempImg, canvas.width, canvas.height, currentPixelSize);
                    }
                    
                    // Divide by 2 (original recursive approach)
                    currentPixelSize = Math.floor(currentPixelSize / 2);
                    
                    // Original acceleration (EXACT: Line 150)
                    intervalDelay *= ACCELERATION;
                    
                    timeoutId = window.setTimeout(nextPixelStep, intervalDelay);
                } else {
                    // Transition complete - fade out canvas
                    onTransitionOutComplete();
                }
            }

            nextPixelStep();
        }

        function onTransitionOutComplete() {
            // Fade in the real content (EXACT timing from component)
            requestAnimationFrame(() => {
                canvas.style.transition = `opacity ${FADE_DURATION}ms ${EASING_CURVE}`;
                canvas.style.opacity = '0';
            });
            
            isAnimating = false;
            
            // Clean up after fade
            setTimeout(() => {
                canvas.style.display = 'none';
                if (timeoutId) clearTimeout(timeoutId);
            }, FADE_DURATION);
        }

        // Start on load with EXACT stagger delay (Line 72)
        window.addEventListener('load', () => {
            const index = 0;
            const staggerDelay = STAGGER_BASE + (index * 100);
            
            setTimeout(() => {
                startPixelatedTransition();
            }, staggerDelay);
        });

        // Handle click - instant redirect
        orb.addEventListener('click', () => {
            window.location.href = 'https://joshualexander.com/music/releases';
        });

        // Cleanup on unmount
        window.addEventListener('beforeunload', () => {
            if (timeoutId) clearTimeout(timeoutId);
        });

        // Initialize 21st.dev toolbar (development only)
        async function initToolbar() {
            // Only initialize in development (localhost)
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                try {
                    // Dynamic import for ES module
                    const { initToolbar } = await import('/node_modules/@21st-extension/toolbar/dist/index.es.js');
                    
                    const stagewiseConfig = {
                        plugins: [],
                    };
                    
                    initToolbar(stagewiseConfig);
                    console.log('21st.dev toolbar initialized');
                } catch (error) {
                    console.warn('Could not load 21st.dev toolbar:', error);
                    console.warn('Make sure you are using a dev server that can serve node_modules');
                }
            }
        }

        // Initialize toolbar after page loads
        window.addEventListener('load', () => {
            initToolbar();
        });
    </script>
</body>
</html>
